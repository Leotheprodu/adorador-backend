// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["omitApi"]
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model Users {
  id                  Int                   @id @default(autoincrement())
  name                String
  email               String?
  phone               String                @unique // Ahora es requerido y único para autenticación
  password            String
  refreshToken        String?               @db.Text
  birthdate           DateTime?
  status              String                @default("inactive")
  createdAt           DateTime              @default(now())
  updatedAt           DateTime              @updatedAt
  tokens              Temporal_token_pool[]
  memberships         Memberships[]
  roles               Roles[]
  membersofBands      MembersofBands[]
  receivedInvitations BandInvitations[]     @relation("InvitedUser")
  sentInvitations     BandInvitations[]     @relation("Inviter")

  // Feed Social relations
  posts            Posts[]            @relation("PostAuthor")
  comments         Comments[]         @relation("CommentAuthor")
  blessings        Blessings[]        @relation("UserBlessings")
  commentBlessings CommentBlessings[] @relation("UserCommentBlessings")
  songCopies       SongCopies[]       @relation("UserSongCopies")
  notifications    Notifications[]    @relation("UserNotifications")

  // Subscription relations
  paymentsMade     PaymentHistory[] @relation("PaymentPaidBy")
  paymentsApproved PaymentHistory[] @relation("PaymentApprovedBy")
  createdBands     Bands[]          @relation("BandCreator")
  trialHistory     TrialHistory[]   @relation("TrialHistoryUser")

  @@map("Users")
}

model Roles {
  id        Int      @id @default(autoincrement())
  name      String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  users     Users[]

  @@map("Roles")
}

model Temporal_token_pool {
  id        Int      @id @default(autoincrement())
  token     String   @unique
  userPhone String // Cambio de userEmail a userPhone
  user      Users    @relation(fields: [userPhone], references: [phone])
  type      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("Temporal_token_pool")
}

model Churches {
  id          Int           @id @default(autoincrement())
  name        String        @unique
  country     String
  address     String
  aniversary  DateTime?
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  memberships Memberships[]

  @@map("Churches")
}

model Bands {
  id   Int    @id @default(autoincrement())
  name String @unique

  // Anti-exploit: Soft delete
  deletedAt DateTime? // NULL = activa, NOT NULL = archivada
  deletedBy Int? // Usuario que archivó

  // Anti-exploit: Tracking de creación
  createdBy Int // Usuario que creó la banda (para límites y trials)
  creator   Users @relation("BandCreator", fields: [createdBy], references: [id])

  events      Events[]
  songs       Songs[]
  members     MembersofBands[]
  invitations BandInvitations[]
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt

  // Feed Social relations
  posts         Posts[]      @relation("PostBand")
  receivedSongs SongCopies[] @relation("BandReceivedSongs")

  // Subscription relations
  subscription BandSubscriptions?
  trialHistory TrialHistory[]     @relation("TrialHistoryBand")

  @@index([deletedAt]) // Filtrar bandas activas/archivadas
  @@index([createdBy, deletedAt]) // Contar bandas activas por usuario
  @@map("Bands")
}

model MembersofBands {
  id             Int      @id @default(autoincrement())
  user           Users    @relation(fields: [userId], references: [id])
  userId         Int
  band           Bands    @relation(fields: [bandId], references: [id])
  bandId         Int
  role           String // Rol del miembro en la banda (ej. vocalista, guitarrista, etc.)
  active         Boolean  @default(true) // Controla si el miembro está activo en la banda
  isAdmin        Boolean  @default(false) // Controla si el miembro es administrador de la banda
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  isEventManager Boolean  @default(false) // Controla si el miembro es el encargado de eventos de la banda

  @@map("MembersofBands")
}

model BandInvitations {
  id            Int      @id @default(autoincrement())
  bandId        Int
  invitedUserId Int
  invitedBy     Int
  status        String   @default("pending") // pending, accepted, rejected, expired
  createdAt     DateTime @default(now())
  expiresAt     DateTime

  band        Bands @relation(fields: [bandId], references: [id], onDelete: Cascade)
  invitedUser Users @relation("InvitedUser", fields: [invitedUserId], references: [id], onDelete: Cascade)
  inviter     Users @relation("Inviter", fields: [invitedBy], references: [id], onDelete: Cascade)

  @@index([invitedUserId, status])
  @@index([bandId])
  @@index([bandId, invitedUserId, status])
  @@map("BandInvitations")
}

model Memberships {
  id          Int                 @id @default(autoincrement())
  user        Users               @relation(fields: [userId], references: [id])
  userId      Int
  church      Churches            @relation(fields: [churchId], references: [id])
  churchId    Int
  active      Boolean             @default(false) // Controla si el usuario es aceptado como miembro
  memberSince DateTime            @default(now())
  roles       ChurchMemberRoles[] // Relación con los roles dentro de la iglesia
  createdAt   DateTime            @default(now())
  updatedAt   DateTime            @updatedAt

  @@unique([userId, churchId]) // Asegura que un usuario solo puede tener una membresía por iglesia
  @@map("Memberships")
}

model ChurchMemberRoles {
  id           Int         @id @default(autoincrement())
  membership   Memberships @relation(fields: [membershipId], references: [id])
  membershipId Int
  role         ChurchRoles @relation(fields: [roleId], references: [id]) // Relación con la tabla de roles de las iglesias
  roleId       Int
  startDate    DateTime    @default(now())
  endDate      DateTime?
  active       Boolean     @default(true) // Controla si el rol está activo o no

  @@index([membershipId])
  @@index([roleId])
  @@map("ChurchMemberRoles")
}

model ChurchRoles {
  id          Int                 @id @default(autoincrement())
  name        String              @unique // Nombre del rol (pastor, líder de alabanza, etc.)
  description String? // Descripción del rol si es necesario
  churchRoles ChurchMemberRoles[]

  @@map("ChurchRoles")
}

model Events {
  id        Int           @id @default(autoincrement())
  title     String
  date      DateTime
  bandId    Int
  band      Bands         @relation(fields: [bandId], references: [id])
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt
  songs     SongsEvents[]

  @@map("Events")
}

model Songs {
  id          Int            @id @default(autoincrement())
  title       String
  artist      String?
  bandId      Int
  band        Bands          @relation(fields: [bandId], references: [id])
  songType    String         @default("worship")
  youtubeLink String?
  key         String?
  tempo       Int?
  lyrics      Songs_lyrics[]
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt
  events      SongsEvents[]

  // Feed Social relations
  sharedInPosts    Posts[]      @relation("SharedSong")
  sharedInComments Comments[]   @relation("CommentSharedSong")
  originalCopies   SongCopies[] @relation("OriginalSongCopies")
  copiedFrom       SongCopies?  @relation("CopiedSong")

  @@unique([title, bandId], name: "unique_song_per_band")
  @@map("Songs")
}

model SongsEvents {
  eventId   Int
  songId    Int
  event     Events @relation(fields: [eventId], references: [id], onDelete: Cascade)
  song      Songs  @relation(fields: [songId], references: [id], onDelete: Cascade)
  transpose Int    @default(0)
  order     Int    @default(0)

  @@id([eventId, songId])
  @@map("SongsEvents")
}

model Songs_Structures {
  id        Int            @id @default(autoincrement())
  title     String         @unique
  lyrics    Songs_lyrics[]
  createdAt DateTime       @default(now())
  updatedAt DateTime       @updatedAt

  @@map("Songs_Structures")
}

model Songs_lyrics {
  id          Int              @id @default(autoincrement())
  songId      Int
  song        Songs            @relation(fields: [songId], references: [id])
  structureId Int
  structure   Songs_Structures @relation(fields: [structureId], references: [id])
  lyrics      String
  chords      Songs_Chords[]
  position    Int              @default(0)
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt

  @@map("Songs_lyrics")
}

model Songs_Chords {
  id           Int          @id @default(autoincrement())
  lyricId      Int
  lyric        Songs_lyrics @relation(fields: [lyricId], references: [id])
  rootNote     String
  chordQuality String?      @default("")
  slashChord   String?      @default("")
  position     Int          @default(0)
  createdAt    DateTime     @default(now())
  updatedAt    DateTime     @updatedAt

  @@map("Songs_Chords")
}

// ============================================
// FEED SOCIAL MODELS
// ============================================

enum PostType {
  SONG_REQUEST // Pidiendo una canción
  SONG_SHARE // Compartiendo una canción

  @@map("PostType")
}

enum PostStatus {
  ACTIVE
  RESOLVED // Para requests que ya fueron resueltos
  DELETED

  @@map("PostStatus")
}

model Posts {
  id     Int        @id @default(autoincrement())
  type   PostType // request o share
  status PostStatus @default(ACTIVE)

  // Relaciones
  authorId Int
  author   Users @relation("PostAuthor", fields: [authorId], references: [id], onDelete: Cascade)

  bandId Int // Banda del autor
  band   Bands @relation("PostBand", fields: [bandId], references: [id], onDelete: Cascade)

  // Para SONG_SHARE: canción que está compartiendo
  sharedSongId Int?
  sharedSong   Songs? @relation("SharedSong", fields: [sharedSongId], references: [id], onDelete: Cascade)

  // Contenido
  title       String  @db.VarChar(200) // Ej: "Busco 'Como en el cielo' de Elevation"
  description String? @db.Text // Detalles adicionales

  // Metadata para requests
  requestedSongTitle  String? @db.VarChar(200) // Si está pidiendo
  requestedArtist     String? @db.VarChar(150)
  requestedYoutubeUrl String? @db.VarChar(300) // URL de YouTube para solicitudes

  // Engagement
  blessings  Blessings[]
  comments   Comments[]
  songCopies SongCopies[] // Quién copió la canción compartida

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([type, status, createdAt])
  @@index([authorId])
  @@index([bandId])
  @@index([sharedSongId])
  @@map("Posts")
}

model Comments {
  id      Int    @id @default(autoincrement())
  content String @db.Text

  // Relaciones
  postId Int
  post   Posts @relation(fields: [postId], references: [id], onDelete: Cascade)

  authorId Int
  author   Users @relation("CommentAuthor", fields: [authorId], references: [id], onDelete: Cascade)

  // Para compartir canción como respuesta a SONG_REQUEST
  sharedSongId Int?
  sharedSong   Songs? @relation("CommentSharedSong", fields: [sharedSongId], references: [id], onDelete: Cascade)

  // Reply system (opcional para MVP, útil después)
  parentId Int?
  parent   Comments?  @relation("CommentReplies", fields: [parentId], references: [id], onDelete: Cascade)
  replies  Comments[] @relation("CommentReplies")

  // Blessings para comentarios
  blessings CommentBlessings[]

  // Canciones copiadas desde este comentario
  songCopies SongCopies[] @relation("CommentSongCopies")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([postId, createdAt])
  @@index([authorId])
  @@index([sharedSongId])
  @@map("Comments")
}

model Blessings {
  id Int @id @default(autoincrement())

  postId Int
  post   Posts @relation(fields: [postId], references: [id], onDelete: Cascade)

  userId Int
  user   Users @relation("UserBlessings", fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([postId, userId]) // Un usuario solo puede dar 1 blessing por post
  @@index([userId])
  @@index([postId])
  @@map("Blessings")
}

model CommentBlessings {
  id Int @id @default(autoincrement())

  commentId Int
  comment   Comments @relation(fields: [commentId], references: [id], onDelete: Cascade)

  userId Int
  user   Users @relation("UserCommentBlessings", fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([commentId, userId]) // Un usuario solo puede dar 1 blessing por comentario
  @@index([userId])
  @@index([commentId])
  @@map("CommentBlessings")
}

model SongCopies {
  id Int @id @default(autoincrement())

  // Post del que se copió (opcional, puede ser null si se copió desde un comentario)
  postId Int?
  post   Posts? @relation(fields: [postId], references: [id], onDelete: Cascade)

  // Comentario del que se copió (opcional, para respuestas a SONG_REQUEST)
  commentId Int?
  comment   Comments? @relation("CommentSongCopies", fields: [commentId], references: [id], onDelete: Cascade)

  // Canción original compartida
  originalSongId Int
  originalSong   Songs @relation("OriginalSongCopies", fields: [originalSongId], references: [id], onDelete: Cascade)

  // Nueva canción creada (copia)
  copiedSongId Int   @unique
  copiedSong   Songs @relation("CopiedSong", fields: [copiedSongId], references: [id], onDelete: Cascade)

  // Usuario que copió
  userId Int
  user   Users @relation("UserSongCopies", fields: [userId], references: [id], onDelete: Cascade)

  // Banda destino
  targetBandId Int
  targetBand   Bands @relation("BandReceivedSongs", fields: [targetBandId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@index([postId])
  @@index([commentId])
  @@index([userId])
  @@index([targetBandId])
  @@map("SongCopies")
}

// Notificaciones generales del sistema
model Notifications {
  id Int @id @default(autoincrement())

  // Usuario que recibe la notificación
  userId Int
  user   Users @relation("UserNotifications", fields: [userId], references: [id], onDelete: Cascade)

  // Tipo de notificación
  type NotificationType

  // Título y contenido
  title   String
  message String @db.Text

  // Datos adicionales en JSON (postId, commentId, invitationId, etc.)
  metadata Json?

  // Estado
  read Boolean @default(false)

  // Timestamps
  createdAt DateTime @default(now())
  readAt    DateTime?

  @@index([userId, read])
  @@index([createdAt])
  @@map("Notifications")
}

enum NotificationType {
  COMMENT_ON_POST // Alguien comentó en tu publicación
  REPLY_TO_COMMENT // Alguien respond a tu comentario
  BLESSING_ON_POST // Alguien bendijo tu publicación
  SONG_COPIED // Alguien copió tu canción compartida
  BAND_INVITATION // Invitación a una banda
  BAND_INVITATION_ACCEPTED // Aceptaron tu invitación
  BAND_INVITATION_REJECTED // Rechazaron tu invitación
}

// ============================================================================
// SUBSCRIPTION SYSTEM
// ============================================================================

// Plan Types
enum PlanType {
  TRIAL
  BASIC
  PROFESSIONAL
  PREMIUM

  @@map("PlanType")
}

// Subscription Status
enum SubscriptionStatus {
  TRIAL // En período de prueba
  ACTIVE // Pagada y activa
  PAYMENT_PENDING // Esperando aprobación de pago
  GRACE_PERIOD // En período de gracia (3 días después de expiración)
  EXPIRED // Expirada (después de período de gracia)
  CANCELLED // Cancelada

  @@map("SubscriptionStatus")
}

// Payment Methods
enum PaymentMethod {
  PAYPAL
  SINPE_MOVIL
  BANK_TRANSFER

 @@map("PaymentMethod")
}

// Payment Status
enum PaymentStatus {
  PENDING // Esperando aprobación
  APPROVED // Aprobado por admin
  REJECTED // Rechazado

  @@map("PaymentStatus")
}

// Subscription Plans (catálogo de planes disponibles)
model SubscriptionPlans {
  id   Int      @id @default(autoincrement())
  name String   @unique // "Trial", "Básico Mensual", "Básico Anual", etc.
  type PlanType // TRIAL, BASIC, PROFESSIONAL, PREMIUM (can have multiple per type for different durations)
  price       Decimal @db.Decimal(10, 2) // 0.00, 10.00, 25.00, 50.00
  currency    String  @default("USD")

  // Límites del plan
  maxMembers        Int // Máximo de miembros en la banda
  maxSongs          Int // Máximo de canciones en base de datos
  maxEventsPerMonth Int // Máximo de eventos por mes
  maxPeoplePerEvent Int // Máximo de personas simultáneas en evento

  // Duración
  durationDays Int? // null o 30 = mensual, 365 = anual, 15 = trial de 15 días

  active    Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  subscriptions BandSubscriptions[]

  @@map("SubscriptionPlans")
}

// Suscripción de cada banda
model BandSubscriptions {
  id     Int   @id @default(autoincrement())
  bandId Int   @unique // Una banda solo puede tener una suscripción activa
  band   Bands @relation(fields: [bandId], references: [id], onDelete: Cascade)

  planId Int
  plan   SubscriptionPlans @relation(fields: [planId], references: [id])

  status SubscriptionStatus @default(TRIAL)

  // Fechas importantes
  trialStartDate     DateTime? // Cuándo empezó el trial
  trialEndDate       DateTime? // Cuándo termina el trial
  currentPeriodStart DateTime // Inicio del período actual
  currentPeriodEnd   DateTime // Fin del período actual
  gracePeriodEnd     DateTime? // Fin del período de gracia (3 días después de expiración)

  // Histórico
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relaciones
  payments PaymentHistory[]

  @@index([bandId, status])
  @@index([currentPeriodEnd])
  @@map("BandSubscriptions")
}

// Historial de pagos
model PaymentHistory {
  id             Int               @id @default(autoincrement())
  subscriptionId Int
  subscription   BandSubscriptions @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)

  amount   Decimal       @db.Decimal(10, 2)
  currency String        @default("USD")
  method   PaymentMethod
  status   PaymentStatus @default(PENDING)

  // Información del pago
  paidByUserId Int? // Usuario que reportó el pago
  paidByUser   Users? @relation("PaymentPaidBy", fields: [paidByUserId], references: [id])

  // Comprobante/referencia
  referenceNumber String? // Número de referencia del pago
  proofImageUrl   String? // URL de la imagen del comprobante
  notes           String? @db.Text // Notas del usuario al pagar

  // Aprobación manual (solo super admin)
  approvedByUserId Int? // Super admin que aprobó
  approvedByUser   Users? @relation("PaymentApprovedBy", fields: [approvedByUserId], references: [id])
  approvedAt       DateTime?
  rejectionReason  String? @db.Text

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([subscriptionId])
  @@index([status])
  @@map("PaymentHistory")
}

// Historial de trials usados (previene abuso)
model TrialHistory {
  id        Int    @id @default(autoincrement())
  userId    Int // Usuario que creó la banda
  user      Users  @relation("TrialHistoryUser", fields: [userId], references: [id])
  userPhone String // Teléfono del usuario (KEY para prevenir múltiples cuentas)
  bandId    Int // Banda que obtuvo el trial
  band      Bands  @relation("TrialHistoryBand", fields: [bandId], references: [id])

  trialStartDate DateTime // Cuándo empezó el trial
  trialEndDate   DateTime // Cuándo terminó

  createdAt DateTime @default(now())

  @@index([userPhone]) // Búsqueda rápida por teléfono
  @@index([userId]) // Búsqueda por usuario
  @@map("TrialHistory")
}

