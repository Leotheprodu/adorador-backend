// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["omitApi"]
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model Users {
  id                  Int                   @id @default(autoincrement())
  name                String
  email               String?
  phone               String                @unique // Ahora es requerido y único para autenticación
  password            String
  refreshToken        String?               @db.Text
  birthdate           DateTime?
  status              String                @default("inactive")
  createdAt           DateTime              @default(now())
  updatedAt           DateTime              @updatedAt
  tokens              Temporal_token_pool[]
  memberships         Memberships[]
  roles               Roles[]
  membersofBands      MembersofBands[]
  receivedInvitations BandInvitations[]     @relation("InvitedUser")
  sentInvitations     BandInvitations[]     @relation("Inviter")

  // Feed Social relations
  posts            Posts[]            @relation("PostAuthor")
  comments         Comments[]         @relation("CommentAuthor")
  blessings        Blessings[]        @relation("UserBlessings")
  commentBlessings CommentBlessings[] @relation("UserCommentBlessings")
  songCopies       SongCopies[]       @relation("UserSongCopies")

  @@map("Users")
}

model Roles {
  id        Int      @id @default(autoincrement())
  name      String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  users     Users[]

  @@map("Roles")
}

model Temporal_token_pool {
  id        Int      @id @default(autoincrement())
  token     String   @unique
  userPhone String // Cambio de userEmail a userPhone
  user      Users    @relation(fields: [userPhone], references: [phone])
  type      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("Temporal_token_pool")
}

model Churches {
  id          Int           @id @default(autoincrement())
  name        String        @unique
  country     String
  address     String
  aniversary  DateTime?
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  memberships Memberships[]

  @@map("Churches")
}

model Bands {
  id          Int               @id @default(autoincrement())
  name        String            @unique
  events      Events[]
  songs       Songs[]
  members     MembersofBands[]
  invitations BandInvitations[]
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt

  // Feed Social relations
  posts         Posts[]      @relation("PostBand")
  receivedSongs SongCopies[] @relation("BandReceivedSongs")

  @@map("Bands")
}

model MembersofBands {
  id             Int      @id @default(autoincrement())
  user           Users    @relation(fields: [userId], references: [id])
  userId         Int
  band           Bands    @relation(fields: [bandId], references: [id])
  bandId         Int
  role           String // Rol del miembro en la banda (ej. vocalista, guitarrista, etc.)
  active         Boolean  @default(true) // Controla si el miembro está activo en la banda
  isAdmin        Boolean  @default(false) // Controla si el miembro es administrador de la banda
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  isEventManager Boolean  @default(false) // Controla si el miembro es el encargado de eventos de la banda

  @@map("MembersofBands")
}

model BandInvitations {
  id            Int      @id @default(autoincrement())
  bandId        Int
  invitedUserId Int
  invitedBy     Int
  status        String   @default("pending") // pending, accepted, rejected, expired
  createdAt     DateTime @default(now())
  expiresAt     DateTime

  band        Bands @relation(fields: [bandId], references: [id], onDelete: Cascade)
  invitedUser Users @relation("InvitedUser", fields: [invitedUserId], references: [id], onDelete: Cascade)
  inviter     Users @relation("Inviter", fields: [invitedBy], references: [id], onDelete: Cascade)

  @@index([invitedUserId, status])
  @@index([bandId])
  @@index([bandId, invitedUserId, status])
  @@map("BandInvitations")
}

model Memberships {
  id          Int                 @id @default(autoincrement())
  user        Users               @relation(fields: [userId], references: [id])
  userId      Int
  church      Churches            @relation(fields: [churchId], references: [id])
  churchId    Int
  active      Boolean             @default(false) // Controla si el usuario es aceptado como miembro
  memberSince DateTime            @default(now())
  roles       ChurchMemberRoles[] // Relación con los roles dentro de la iglesia
  createdAt   DateTime            @default(now())
  updatedAt   DateTime            @updatedAt

  @@unique([userId, churchId]) // Asegura que un usuario solo puede tener una membresía por iglesia
  @@map("Memberships")
}

model ChurchMemberRoles {
  id           Int         @id @default(autoincrement())
  membership   Memberships @relation(fields: [membershipId], references: [id])
  membershipId Int
  role         ChurchRoles @relation(fields: [roleId], references: [id]) // Relación con la tabla de roles de las iglesias
  roleId       Int
  startDate    DateTime    @default(now())
  endDate      DateTime?
  active       Boolean     @default(true) // Controla si el rol está activo o no

  @@index([membershipId])
  @@index([roleId])
  @@map("ChurchMemberRoles")
}

model ChurchRoles {
  id          Int                 @id @default(autoincrement())
  name        String              @unique // Nombre del rol (pastor, líder de alabanza, etc.)
  description String? // Descripción del rol si es necesario
  churchRoles ChurchMemberRoles[]

  @@map("ChurchRoles")
}

model Events {
  id        Int           @id @default(autoincrement())
  title     String
  date      DateTime
  bandId    Int
  band      Bands         @relation(fields: [bandId], references: [id])
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt
  songs     SongsEvents[]

  @@map("Events")
}

model Songs {
  id          Int            @id @default(autoincrement())
  title       String
  artist      String?
  bandId      Int
  band        Bands          @relation(fields: [bandId], references: [id])
  songType    String         @default("worship")
  youtubeLink String?
  key         String?
  tempo       Int?
  lyrics      Songs_lyrics[]
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt
  events      SongsEvents[]

  // Feed Social relations
  sharedInPosts     Posts[]      @relation("SharedSong")
  sharedInComments  Comments[]   @relation("CommentSharedSong")
  originalCopies    SongCopies[] @relation("OriginalSongCopies")
  copiedFrom        SongCopies?  @relation("CopiedSong")

  @@unique([title, bandId], name: "unique_song_per_band")
  @@map("Songs")
}

model SongsEvents {
  eventId   Int
  songId    Int
  event     Events @relation(fields: [eventId], references: [id], onDelete: Cascade)
  song      Songs  @relation(fields: [songId], references: [id], onDelete: Cascade)
  transpose Int    @default(0)
  order     Int    @default(0)

  @@id([eventId, songId])
  @@map("SongsEvents")
}

model Songs_Structures {
  id        Int            @id @default(autoincrement())
  title     String         @unique
  lyrics    Songs_lyrics[]
  createdAt DateTime       @default(now())
  updatedAt DateTime       @updatedAt

  @@map("Songs_Structures")
}

model Songs_lyrics {
  id          Int              @id @default(autoincrement())
  songId      Int
  song        Songs            @relation(fields: [songId], references: [id])
  structureId Int
  structure   Songs_Structures @relation(fields: [structureId], references: [id])
  lyrics      String
  chords      Songs_Chords[]
  position    Int              @default(0)
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt

  @@map("Songs_lyrics")
}

model Songs_Chords {
  id           Int          @id @default(autoincrement())
  lyricId      Int
  lyric        Songs_lyrics @relation(fields: [lyricId], references: [id])
  rootNote     String
  chordQuality String?      @default("")
  slashChord   String?      @default("")
  position     Int          @default(0)
  createdAt    DateTime     @default(now())
  updatedAt    DateTime     @updatedAt

  @@map("Songs_Chords")
}

// ============================================
// FEED SOCIAL MODELS
// ============================================

enum PostType {
  SONG_REQUEST // Pidiendo una canción
  SONG_SHARE // Compartiendo una canción

  @@map("PostType")
}

enum PostStatus {
  ACTIVE
  RESOLVED // Para requests que ya fueron resueltos
  DELETED

  @@map("PostStatus")
}

model Posts {
  id     Int        @id @default(autoincrement())
  type   PostType // request o share
  status PostStatus @default(ACTIVE)

  // Relaciones
  authorId Int
  author   Users @relation("PostAuthor", fields: [authorId], references: [id], onDelete: Cascade)

  bandId Int // Banda del autor
  band   Bands @relation("PostBand", fields: [bandId], references: [id], onDelete: Cascade)

  // Para SONG_SHARE: canción que está compartiendo
  sharedSongId Int?
  sharedSong   Songs? @relation("SharedSong", fields: [sharedSongId], references: [id], onDelete: Cascade)

  // Contenido
  title       String  @db.VarChar(200) // Ej: "Busco 'Como en el cielo' de Elevation"
  description String? @db.Text // Detalles adicionales

  // Metadata para requests
  requestedSongTitle String? @db.VarChar(200) // Si está pidiendo
  requestedArtist    String? @db.VarChar(150)
  requestedYoutubeUrl String? @db.VarChar(300) // URL de YouTube para solicitudes

  // Engagement
  blessings  Blessings[]
  comments   Comments[]
  songCopies SongCopies[] // Quién copió la canción compartida

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([type, status, createdAt])
  @@index([authorId])
  @@index([bandId])
  @@index([sharedSongId])
  @@map("Posts")
}

model Comments {
  id      Int    @id @default(autoincrement())
  content String @db.Text

  // Relaciones
  postId Int
  post   Posts @relation(fields: [postId], references: [id], onDelete: Cascade)

  authorId Int
  author   Users @relation("CommentAuthor", fields: [authorId], references: [id], onDelete: Cascade)

  // Para compartir canción como respuesta a SONG_REQUEST
  sharedSongId Int?
  sharedSong   Songs? @relation("CommentSharedSong", fields: [sharedSongId], references: [id], onDelete: Cascade)

  // Reply system (opcional para MVP, útil después)
  parentId Int?
  parent   Comments?  @relation("CommentReplies", fields: [parentId], references: [id], onDelete: Cascade)
  replies  Comments[] @relation("CommentReplies")

  // Blessings para comentarios
  blessings CommentBlessings[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([postId, createdAt])
  @@index([authorId])
  @@index([sharedSongId])
  @@map("Comments")
}

model Blessings {
  id Int @id @default(autoincrement())

  postId Int
  post   Posts @relation(fields: [postId], references: [id], onDelete: Cascade)

  userId Int
  user   Users @relation("UserBlessings", fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([postId, userId]) // Un usuario solo puede dar 1 blessing por post
  @@index([userId])
  @@index([postId])
  @@map("Blessings")
}

model CommentBlessings {
  id Int @id @default(autoincrement())

  commentId Int
  comment   Comments @relation(fields: [commentId], references: [id], onDelete: Cascade)

  userId Int
  user   Users @relation("UserCommentBlessings", fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([commentId, userId]) // Un usuario solo puede dar 1 blessing por comentario
  @@index([userId])
  @@index([commentId])
  @@map("CommentBlessings")
}

model SongCopies {
  id Int @id @default(autoincrement())

  // Post del que se copió
  postId Int
  post   Posts @relation(fields: [postId], references: [id], onDelete: Cascade)

  // Canción original compartida
  originalSongId Int
  originalSong   Songs @relation("OriginalSongCopies", fields: [originalSongId], references: [id], onDelete: Cascade)

  // Nueva canción creada (copia)
  copiedSongId Int   @unique
  copiedSong   Songs @relation("CopiedSong", fields: [copiedSongId], references: [id], onDelete: Cascade)

  // Usuario que copió
  userId Int
  user   Users @relation("UserSongCopies", fields: [userId], references: [id], onDelete: Cascade)

  // Banda destino
  targetBandId Int
  targetBand   Bands @relation("BandReceivedSongs", fields: [targetBandId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@index([postId])
  @@index([userId])
  @@index([targetBandId])
  @@map("SongCopies")
}
